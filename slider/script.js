window.onload = () => {
  const slider = document.querySelector('.slider')
  const track = slider.querySelector('.slider__track')
  const slides = track.querySelectorAll('.slide')

  const dots = {
    elements: [...document.querySelectorAll('.slider__dot')],
    setActive: function (active) {
      this.elements[active].classList.add('slider__dot--active')
    },
    clearActive: function () {
      this.elements.forEach((dot) =>
        dot.classList.remove('slider__dot--active')
      )
    },
  }

  const controls = {
    add: () => slider.addEventListener('click', changeSlide),
    remove: () => slider.removeEventListener('click', changeSlide),
  }

  let currSlide = 0

  // Works best with 5*n
  const step = 10

  const imageSize = slides[0].clientWidth

  // Adaptive gap size
  const gap = slides[1].offsetLeft - imageSize
  const fullImageSize = imageSize + gap

  const animateSlide = (start, end) => {
    // Solution for endless scroll
    // Creates placeholder variable for 'cleaning' stage in interval for edge case
    let placeholder
    if (end < 0) {
      // Clones image and places it right before/after current one
      placeholder = slides[slides.length - 1].cloneNode(false)
      slides[0].before(placeholder)
      // When we create element before the current one, they all bump up by one, fixed by mutating start and end (not the best practice)
      // It seems like browser pipeline is taking a while to clone element and/or rerender the page with incremented position, therefore some flashing can be observed.
      start++
      end++
    } else if (end === slides.length) {
      placeholder = slides[0].cloneNode(false)
      slides[slides.length - 1].after(placeholder)
    }

    // Calculate start and end value of translateX
    let position = -fullImageSize * start
    const endPosition = -fullImageSize * end

    const animate = (step) => {
      // To boost slider if some images are skipped
      const imagesBetween =
        Math.abs(position - endPosition) / (imageSize + gap) - 1
      const newStep = imagesBetween > 0 ? step * imagesBetween : step

      const animation = setInterval(() => {
        track.style.transform = `translateX(${(position += newStep)}px)`

        // Complex if statement for cases if step != [1,5,10 ...] because in such cases some pixels will be left during transition (i.e. 10 - 7 = 3, 3 - 7 will generate infinite loop), so we have to compare substraction result to modulo of step
        if (
          endPosition - position <= Math.abs(newStep) &&
          endPosition - position >= 0
        ) {
          clearInterval(animation)
          controls.add()
          // Remove placeholder if it was generated and fix order
          if (placeholder) {
            if (end === 0) {
              currSlide = slides.length - 1
            } else {
              currSlide = 0
            }
            placeholder.remove()
          } else {
            currSlide = end
          }

          // To seemlessly change from last picture to first and vice versa
          // Also foolproof to make picture straight in the center if other values of step than 1/5/10... are used
          track.style.transform = `translateX(${-fullImageSize * currSlide}px)`

          dots.setActive(currSlide)
        }
      }, 1)
    }

    position > endPosition ? animate(-step) : animate(step)
  }

  const changeSlide = ({ target }) => {
    // Check if element has dataset value during bubbling of event
    if (!target.dataset.slide) return
    // Check if bubbled event generated by arrow or dot and set nextSlide accordingly
    const nextSlide = target.classList.contains('arrow')
      ? +target.dataset.slide + currSlide
      : +target.dataset.slide
    // Check for dots to not slide to the same picture
    if (nextSlide === currSlide) return

    controls.remove()

    dots.clearActive()
    animateSlide(currSlide, nextSlide)
  }

  const init = () => {
    track.style.transform = `translateX(${-fullImageSize * currSlide}px`
    dots.setActive(currSlide)
    controls.add()
  }

  init()
}
